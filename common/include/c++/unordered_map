#ifndef __CXX_UNORDERED_MAP
#define __CXX_UNORDERED_MAP
#include "bits/hashtable.hpp"
#include "bits/dragon.hpp"
namespace std 
{ 
    template<typename KT, typename VT, __detail::__hash_functor<KT> HT = ext::dragon<KT>, __detail::__predicate<KT> ET = equal_to<void>, allocator_object<pair<const KT, VT>> AT = allocator<pair<const KT, VT>>>
    class unordered_map : public __hashtable_base<KT, pair<const KT, VT>, HT, __impl::__pair_key_extract<const KT, VT>, ET, AT>
    {
        typedef VT mapped_type;
    protected:
        using __base = __hashtable_base<KT, pair<const KT, VT>, HT, __impl::__pair_key_extract<const KT, VT>, ET, AT>;
        using typename __base::__scoped_node;
        using typename __base::__node_ptr;
    public:
        typedef typename __base::__size_type size_type;
        typedef typename __base::__difference_type difference_type;
        typedef typename __base::__key_type key_type;
        typedef typename __base::__value_type value_type;
        typedef typename __base::__iterator iterator;
        typedef typename __base::__const_iterator const_iterator;
        size_type size() const noexcept { return this->__size(); }
        size_type bucket_count() const noexcept { return this->__num_buckets(); }
        void clear() { this->__clear(); }
        template<convertible_to<KT> LT> iterator find(LT const& lt) { return this->__find(lt); }
        template<typename ... Args> requires constructible_from<value_type, Args...> pair<iterator, bool> emplace(Args&& ... args) { return this->__emplace_unique(forward<Args>(args)...); }
        template<convertible_to<KT> LT> size_type erase(LT const& lt) { return this->__erase_unique(lt); }
        iterator begin() noexcept { return iterator(this->__begin()); }
        const_iterator cbegin() const noexcept { return const_iterator(this->__begin()); }
        const_iterator begin() const noexcept { return cbegin(); }
        iterator end() noexcept { return iterator(nullptr); }
        const_iterator cend() const noexcept { return const_iterator(nullptr); }
        const_iterator end() const noexcept { return cend(); }
        pair<iterator, bool> insert(value_type && vt) { return this->__insert_unique(move(vt)); }
        pair<iterator, bool> insert(value_type const& vt) { return this->__insert_unique(vt); }
        template<convertible_to<VT> WT> pair<iterator, bool> insert_or_assign(KT && key, WT && wt);
        template<convertible_to<VT> WT> pair<iterator, bool> insert_or_assign(KT const& kt, WT && wt);
        template<convertible_to<KT> LT> requires (move_constructible<KT> && is_default_constructible_v<VT>) mapped_type& operator[](LT&& key);
        template<convertible_to<KT> LT> requires (copy_constructible<KT> && is_default_constructible_v<VT>) mapped_type& operator[](LT const& key);
        unordered_map() = default;
        unordered_map(HT const& h) : __base{ h } {}
        unordered_map(HT const& h, size_type buckets_hint) : __base{ h } { size_type target = this->__policy.__next_bucket(buckets_hint); if(target > this->__bucket_count) { this->__my_buckets = this->__allocate_buckets(target); this->__bucket_count = target; } }
    };
    template <typename KT, typename VT, __detail::__hash_functor<KT> HT, __detail::__predicate<KT> ET, allocator_object<pair<const KT, VT>> AT>
    template <convertible_to<KT> LT>
    requires (move_constructible<KT> && is_default_constructible_v<VT>)
    typename unordered_map<KT, VT, HT, ET, AT>::mapped_type &unordered_map<KT, VT, HT, ET, AT>::operator[](LT&& key)
    {
        size_type idx = this->__bucket_key_index(key);
        if(__node_ptr n = this->__find_node(idx, key)) { return n->__get_ref().second; }
        __scoped_node sn{ this, piecewise_construct, forward_as_tuple(move(key)), tuple<>() };
        iterator result = this->__insert_unique_node(idx, sn.__my_node);
        sn.__my_node = nullptr;
        return result->second;
    }
    template <typename KT, typename VT, __detail::__hash_functor<KT> HT, __detail::__predicate<KT> ET, allocator_object<pair<const KT, VT>> AT>
    template <convertible_to<KT> LT>
    requires (copy_constructible<KT> && is_default_constructible_v<VT>)
    typename unordered_map<KT, VT, HT, ET, AT>::mapped_type &unordered_map<KT, VT, HT, ET, AT>::operator[](LT const& key)
    {
        size_type idx = this->__bucket_key_index(key);
        if(__node_ptr n = this->__find_node(idx, key)) { return n->__get_ref().second; }
        __scoped_node sn{ this, piecewise_construct, tuple<KT const&>(key), tuple<>() };
        iterator result = this->__insert_unique_node(idx, sn.__my_node);
        sn.__my_node = nullptr;
        return result->second;
    }
    template <typename KT, typename VT, __detail::__hash_functor<KT> HT, __detail::__predicate<KT> ET, allocator_object<pair<const KT, VT>> AT>
    template <convertible_to<VT> WT>
    pair<typename unordered_map<KT, VT, HT, ET, AT>::iterator, bool> unordered_map<KT, VT, HT, ET, AT>::insert_or_assign(KT && key, WT && wt)
    {
        iterator i = this->__find(key);
        bool inserted = false;
        if(i == this->end()) { __scoped_node sn{ this, piecewise_construct, forward_as_tuple(move(key)), tuple<>() }; i = this->__insert_unique_node(this->__bucket_key_index(key), sn.__my_node); inserted = true; }
        i->second = move(wt);
        return make_pair(i, inserted);
    }
    template <typename KT, typename VT, __detail::__hash_functor<KT> HT, __detail::__predicate<KT> ET, allocator_object<pair<const KT, VT>> AT>
    template <convertible_to<VT> WT>
    pair<typename unordered_map<KT, VT, HT, ET, AT>::iterator, bool> unordered_map<KT, VT, HT, ET, AT>::insert_or_assign(KT const& key, WT && wt)
    {
        iterator i = this->__find(key);
        bool inserted = false;
        if(i == this->end()) { __scoped_node sn{ this, piecewise_construct, tuple<KT const&>(key), tuple<>() }; i = this->__insert_unique_node(this->__bucket_key_index(key), sn.__my_node); inserted = true; }
        i->second = move(wt);
        return make_pair(i, inserted);
    }
}
#endif